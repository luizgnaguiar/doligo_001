MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────

Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) – Arquitetura de Produção

Papel:
Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).

Objetivo Geral:
Projetar, validar e evoluir a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna descritas abaixo.

────────────────────────────────────────────────────────────
1. RESTRIÇÕES DE COMPILAÇÃO E AMBIENTE
────────────────────────────────────────────────────────────

• Binário Estático:
  É TERMINANTEMENTE PROIBIDO o uso de CGO.
  Toda a solução DEVE compilar com CGO_ENABLED=0.

• Drivers Pure Go:
  PostgreSQL: pgx
  MySQL: go-sql-driver/mysql

• Encapsulamento de Assets:
  Todos os arquivos externos (SQL migrations, templates de e-mail/PDF, arquivos i18n JSON)
  DEVEM ser lidos exclusivamente via go:embed.

• Versão do Go:
  Go 1.22 ou superior.

────────────────────────────────────────────────────────────
2. ARQUITETURA E FLUXO DE DADOS
────────────────────────────────────────────────────────────

• Estrutura de Pastas Obrigatória:
  /cmd                  → Entrypoints da aplicação
  /internal/domain       → Entidades puras e interfaces
  /internal/usecase      → Orquestração da lógica de negócio
  /internal/infrastructure → Implementações técnicas
  /internal/api          → Handlers, middlewares e DTOs (Echo v4)

• Mapeamento Rigoroso:
  1. API → Usecase: Handler valida DTO e converte para Entity
  2. Usecase → Repository: apenas Entities
  3. Repository → DB: Entity → Model GORM

• Injeção de Dependência:
  Via construtores manuais no main.go ou wire.
  Interfaces são obrigatórias.

────────────────────────────────────────────────────────────
3. CONCORRÊNCIA E RESILIÊNCIA
────────────────────────────────────────────────────────────

• Todos os métodos de Usecase e Repository DEVEM aceitar context.Context.

• Operações críticas de estoque DEVEM usar Pessimistic Lock:
  db.Clauses(clause.Locking{Strength: "UPDATE"})

• Internal Task Runner:
  Worker Pool baseado em channels.

• Graceful Shutdown:
  Ao receber SIGTERM:
  - parar de aceitar novas tarefas
  - finalizar as existentes em até 15 segundos

• IO pesado (PDF/E-mail):
  Timeout obrigatório de 30 segundos via context.

• Circuit Breaker:
  Retry simples para falhas de envio de e-mail.

────────────────────────────────────────────────────────────
4. PERSISTÊNCIA E INTEGRAÇÕES
────────────────────────────────────────────────────────────

• ORM:
  GORM v2 para CRUD
  SQL puro permitido para relatórios complexos

• Pool de Conexões:
  MaxOpenConns, MaxIdleConns e ConnMaxLifetime via env vars

• Migrações:
  golang-migrate/migrate embutido no binário

• PDFs:
  Biblioteca maroto (pure Go)

────────────────────────────────────────────────────────────
5. SEGURANÇA E OBSERVABILIDADE
────────────────────────────────────────────────────────────

• Auth:
  JWT Stateless
  Middleware RBAC via Claims

• Logs:
  ZeroLog ou Zap
  request_id obrigatório no contexto

• Health:
  /health → liveness
  /ready  → readiness (DB)

────────────────────────────────────────────────────────────
6. CRITÉRIOS DE ACEITE (CASOS DE TESTE)
────────────────────────────────────────────────────────────

CT-01: Portabilidade
CT-02: Concorrência
CT-03: Cancelamento
CT-04: Shutdown

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────

FASE 8.1 — CT-01: Portabilidade e Binário Estático (GATE 0.1)

OBJETIVO DA FASE

Validar de forma explícita, reproduzível e auditável que o sistema gera um binário Go 100% estático, compilado com CGO desabilitado, capaz de executar corretamente em uma imagem Docker scratch.

Sem o atendimento integral desta fase, QUALQUER execução em produção é PROIBIDA.

────────────────────────────────────────────────────────────
ESCOPO ESTRITO DA FASE
────────────────────────────────────────────────────────────

Esta fase trata EXCLUSIVAMENTE de portabilidade de build e runtime mínimo.

É OBRIGATÓRIO comprovar:

1. BUILD ESTÁTICO
• Compilação com:
  CGO_ENABLED=0
  GOOS=linux
• Nenhuma dependência dinâmica de SO
• Nenhum uso de CGO, direto ou indireto

2. EXECUÇÃO EM DOCKER SCRATCH
• Dockerfile mínimo baseado em FROM scratch
• O binário DEVE:
  - iniciar corretamente
  - expor o endpoint /health
  - permanecer em execução sem crash

3. RUNTIME MÍNIMO FUNCIONAL
• O endpoint /health DEVE responder com sucesso
• Conexão com banco de dados NÃO é exigida
• Falhas de dependências externas NÃO DEVEM ser corrigidas nesta fase
• Caso impeçam o boot ou execução mínima, o CT-01 DEVE ser declarado NÃO ATENDIDO

────────────────────────────────────────────────────────────
RESTRIÇÕES ABSOLUTAS
────────────────────────────────────────────────────────────

É TERMINANTEMENTE PROIBIDO:

• Implementar ou alterar regras de negócio
• Modificar domínios, usecases ou handlers
• Introduzir endpoints além do /health
• Ajustar lógica de inicialização além do estritamente necessário para o boot
• Declarar portabilidade sem evidência executável
• Assumir bibliotecas “pure Go” sem validação prática

Qualquer necessidade fora do escopo DEVE ser registrada como DÍVIDA TÉCNICA.

────────────────────────────────────────────────────────────
EVIDÊNCIAS OBRIGATÓRIAS — CT-01
────────────────────────────────────────────────────────────

A fase SÓ é considerada concluída se TODAS as evidências abaixo constarem no SESSION_LOG:

1. COMANDO DE BUILD OBRIGATÓRIO E ÚNICO:
   CGO_ENABLED=0 GOOS=linux go build -o app ./cmd/main.go

2. DOCKERFILE SCRATCH:
• Uso explícito de FROM scratch
• Apenas o binário final (assets via go:embed)

3. EXECUÇÃO COMPROVADA:
• Execução real do container
• Evidência objetiva de resposta do endpoint /health

────────────────────────────────────────────────────────────
CRITÉRIO DE ACEITE TÉCNICO — GATE 0.1
────────────────────────────────────────────────────────────

O GATE 0.1 é considerado ATENDIDO somente se:

• O build estático for bem-sucedido
• O container scratch executar sem falhas
• O endpoint /health responder corretamente
• Todas as evidências estiverem registradas no SESSION_LOG

Caso qualquer item falhe:
• CT-01 = NÃO ATENDIDO
• PRODUÇÃO = BLOQUEADA

────────────────────────────────────────────────────────────
REGRA DE ENCERRAMENTO DA FASE (ANTI-LOOP)
────────────────────────────────────────────────────────────

Esta fase é FAIL-FAST.

Ao PRIMEIRO erro de:
• build
• criação do container
• execução do container
• resposta do endpoint /health

O agente DEVE:
• Declarar imediatamente o CT-01 como NÃO ATENDIDO
• Registrar o erro no SESSION_LOG
• ENCERRAR a execução da fase

É TERMINANTEMENTE PROIBIDO:
• Reexecutar o build
• Variar comandos
• Ajustar código
• Tentar novamente

────────────────────────────────────────────────────────────
SESSION_LOG (OBRIGATÓRIO)
────────────────────────────────────────────────────────────

O SESSION_LOG DEVE:

• Listar apenas arquivos criados ou modificados
• Registrar apenas fatos verificáveis
• Não utilizar termos subjetivos
• Declarar explicitamente se o GATE 0.1 foi ATENDIDO ou NÃO ATENDIDO
