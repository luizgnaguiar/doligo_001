 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────


════════════════════════════════════════════════════════════
FASE 8.1-R — CT-01: Portabilidade e Binário Estático (Docker Scratch)
════════════════════════════════════════════════════════════

OBJETIVO
--------
Reexecutar de forma controlada a validação de portabilidade do binário Go estático,
confirmando a execução correta da aplicação em um container Docker `FROM scratch`,
com inicialização não bloqueante do servidor HTTP e disponibilidade do endpoint
`/health`, mesmo na ausência de dependências externas (ex.: banco de dados).

Esta fase substitui e consolida a FASE 8.1 original, incorporando as correções
implementadas na FASE 8.1.1.

ESCOPO
------
Incluído:
- Build estático do binário Go com `CGO_ENABLED=0` e `GOOS=linux`
- Execução do binário em container `scratch`
- Inicialização imediata do servidor HTTP
- Disponibilidade do endpoint `/health` independentemente do estado do banco
- Falha do banco de dados tratada como erro não fatal
- Logs explícitos de erro de DB sem encerrar o processo
- Execução single-shot (sem loops, retries ou waits)

Excluído:
- Retry automático de banco de dados
- Esperas ativas (`sleep`, polling)
- Backoff, loops de reconexão ou watchdogs
- Liveness/readiness avançados além de `/health`
- Orquestração (K8s, compose, etc.)

RESTRIÇÕES (ANTI-LOOP / ANTI-HANG)
---------------------------------
É EXPRESSAMENTE PROIBIDO:
- Qualquer loop de retry de inicialização
- Qualquer `for` ou `select` dedicado a reconectar dependências
- Qualquer `time.Sleep` para aguardar DB
- Qualquer `log.Fatal`, `panic` ou `os.Exit` em falha de dependência externa
- Qualquer bloqueio do `ListenAndServe` condicionado ao DB

A inicialização do banco DEVE ser:
- Executada em goroutine isolada
- Fail-fast (uma tentativa única)
- Não bloqueante para o servidor HTTP

COMPORTAMENTO ESPERADO
----------------------
1. O binário é compilado estaticamente com sucesso
2. O container `scratch` inicia corretamente
3. O servidor HTTP sobe imediatamente
4. O endpoint `/health` responde HTTP 200
5. A falha de conexão com o banco:
   - É logada como erro
   - NÃO encerra o processo
   - NÃO impede `/health`
6. Rotas dependentes do banco (se existirem):
   - Retornam HTTP 503 enquanto serviços não estiverem prontos

IMPLEMENTAÇÃO DE REFERÊNCIA
---------------------------
- Todas as rotas devem ser registradas ANTES do servidor iniciar
- Rotas dependentes do banco devem ser protegidas por flag thread-safe
- Nenhuma mutação de rotas após `Start()`

VALIDAÇÕES OBRIGATÓRIAS
----------------------
Build:
- `CGO_ENABLED=0 GOOS=linux go build -o app ./cmd/main.go`

Dockerfile (exemplo mínimo esperado):
-------------------------------------
FROM scratch
WORKDIR /
COPY app /app
EXPOSE 8080
ENTRYPOINT ["/app"]

Execução:
---------
- `docker build -t doligo-scratch-test .`
- `docker run --name doligo-test-container -d -p 8080:8080 doligo-scratch-test`

Verificações:
-------------
- `docker ps` → container em execução
- `docker logs doligo-test-container` → logs sem crash
- `curl http://localhost:8080/health` → HTTP 200

CRITÉRIO DE SUCESSO (GATE 0.1)
-----------------------------
GATE 0.1 = ATENDIDO se, e somente se:
- O container permanece em execução
- O endpoint `/health` responde com sucesso
- Nenhum loop, retry ou espera foi introduzido
- A falha de DB não encerra o processo

FORMATO DO LOG DE SESSÃO
-----------------------
Ao final, gerar obrigatoriamente um `SESSION_LOG.txt` contendo:

- Arquivos criados/modificados
- Resumo técnico objetivo
- Resultado explícito do gate (ATENDIDO / NÃO ATENDIDO)
- Lista de comandos executados
- Declaração explícita de ausência de loop/retry/wait

NOTA IMPORTANTE
---------------
Não assumir falhas ambientais.
Conflitos de porta, múltiplas instâncias ou erros de DB devem ser tratados
como condições operacionais normais, nunca como erro do sistema hospedeiro.

════════════════════════════════════════════════════════════
FIM DA FASE 8.1-R — CT-01
════════════════════════════════════════════════════════════
