 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────


FASE 7.2-R — Recovery / Rebaseline Controlado do Repositório
OBJETIVO
Estabelecer formalmente um novo baseline técnico para o projeto, reconhecendo o estado atual do repositório como ponto de partida válido, após refatorações estruturais realizadas fora do controle estrito das Fases 7.1 e 7.2.
Esta fase NÃO introduz mudanças funcionais, NÃO altera código, e NÃO corrige bugs.
Seu único propósito é restaurar a governança do projeto, permitindo a continuidade das fases subsequentes sem violação contratual recorrente.
ESCOPO PERMITIDO
É PERMITIDO nesta fase:
Não modificar nenhum arquivo do repositório
Auditar e declarar explicitamente:
O estado atual dos arquivos
As divergências históricas em relação às Fases 7.1 e 7.2
Registrar no SESSION LOG:
Que o estado atual passa a ser considerado baseline oficial
Que fases futuras devem partir exatamente deste estado
ESCOPO PROIBIDO (REGRA ABSOLUTA)
É TERMINANTEMENTE PROIBIDO nesta fase:
Criar, editar ou remover qualquer arquivo
Reformatar código
Ajustar imports
Corrigir erros
Refatorar nomes
Executar comandos de build como parte da validação
Introduzir lógica de negócio
Ajustar infraestrutura, handlers, usecases ou domínio
Qualquer tentativa de modificação invalida automaticamente a fase.
DIRETRIZES DE REBASELINE (OBRIGATÓRIAS)
O repositório, no estado em que se encontra ao iniciar esta fase, passa a ser considerado:
O baseline oficial do projeto a partir da Fase 7.2-R
Nenhuma inconsistência histórica anterior:
Pode ser atribuída a fases futuras
Pode ser usada para invalidar fases posteriores
Todas as fases subsequentes:
Devem assumir este estado como fonte da verdade
Devem respeitar integralmente os contratos definidos a partir daqui
CRITÉRIO DE ACEITE TÉCNICO (OBRIGATÓRIO)
A fase SÓ é considerada CONCLUÍDA se TODAS as condições abaixo forem verdadeiras:
Nenhum arquivo foi modificado durante a execução da fase
O SESSION LOG declara explicitamente:
A aceitação do estado atual como baseline
Nenhuma tentativa de correção técnica foi realizada
FORMATO DO SESSION LOG (OBRIGATÓRIO)
O log final DEVE seguir exatamente o formato abaixo:
### SESSION_LOG_START | Versão: v1.0.0 | Data: YYYY-MM-DD
- ARQUIVOS CRIADOS/MODIFICADOS:
  - Nenhum

- RESUMO TÉCNICO:
  - Reconhecimento formal do estado atual do repositório como baseline oficial do projeto.
  - Registro de que refatorações e alterações fora do escopo das Fases 7.1 e 7.2 passam a ser consideradas parte do estado consolidado.
  - Nenhuma modificação de código foi realizada nesta fase.

- DÍVIDA TÉCNICA / PENDÊNCIAS:
  - Débitos técnicos existentes permanecem registrados conforme logs anteriores, sem alteração ou correção nesta fase.

- COMANDO DE VALIDAÇÃO:
  - Nenhum (fase declaratória de rebaseline)
### SESSION_LOG_END
CONDIÇÃO DE FALHA AUTOMÁTICA
A Fase 7.2-R deve ser considerada FALHA se:
Qualquer arquivo for modificado
Qualquer correção técnica for aplicada
O SESSION LOG omitir a declaração explícita de rebaseline
O formato do log divergir do padrão exigido
RESULTADO ESPERADO
Ao final da Fase 7.2-R:
O projeto possui novamente governança clara
O estado atual do repositório é a nova fonte da verdade
Fases futuras podem ser executadas sem conflitos contratuais
O looping de invalidação por contexto histórico é eliminado