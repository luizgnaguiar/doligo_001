 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────




## TAREFA ATIVA — FASE 13.3

### CORS CONFIGURÁVEL E HEADERS DE SEGURANÇA

#### CONTEXTO DE EXECUÇÃO

Esta tarefa ocorre após o encerramento formal da FASE 13.2 (Rate Limiting).

O sistema já possui:

* Proteção contra abuso por IP (Rate Limiting) 


* Auditoria de dependências concluída 


* **Vulnerabilidade a ataques de Cross-Origin e falta de políticas de segurança nos headers HTTP**

O objetivo é **implementar o middleware de CORS configurável** e injetar **headers de segurança** essenciais para proteger o cliente e o servidor.

#### OBJETIVO ÚNICO DA TAREFA

Implementar middleware de CORS (Cross-Origin Resource Sharing) no Echo v4, cujas permissões sejam definidas estritamente via variáveis de ambiente, e adicionar headers de segurança (HSTS, X-Frame-Options, CSP básico).

Nada além disso.

#### PROBLEMA A SER RESOLVIDO

Atualmente:

* O sistema não restringe quais domínios podem consumir a API via browser.
* A ausência de headers como `X-Content-Type-Options` e `X-Frame-Options` expõe usuários a ataques de clickjacking e sniffing de MIME.
* Não há política de segurança de conteúdo (CSP) definida.

Esta fase corrige **exclusivamente** isso.

#### ESCOPO AUTORIZADO

Você pode somente:

1. **Implementar** middleware de CORS configurável:
* Utilizar o middleware nativo do Echo: `github.com/labstack/echo/v4/middleware`
* Configurar `AllowOrigins`, `AllowMethods` e `AllowHeaders` via ENV.


2. **Configurar** via variáveis de ambiente:
```bash
CORS_ALLOWED_ORIGINS="https://meu-erp.com,https://admin.meu-erp.com"
CORS_ALLOW_CREDENTIALS=true
SECURITY_HEADERS_ENABLED=true

```


3. **Injetar Headers de Segurança** (Middleware customizado ou nativo):
* `X-Frame-Options: DENY` (Proteção contra Clickjacking)
* `X-Content-Type-Options: nosniff`
* `X-XSS-Protection: 1; mode=block`
* `Strict-Transport-Security: max-age=31536000; includeSubDomains` (HSTS)
* `Content-Security-Policy (CSP)` básico (ex: `default-src 'self'`)


4. **Atualizar** documentação:
* Adicionar variáveis ao `docs/env_vars.md` 


* Criar `docs/security_headers.md` detalhando a política adotada.



#### RESTRIÇÕES ABSOLUTAS

Nesta fase, **NÃO** é permitido:

* Adicionar bibliotecas externas de segurança além do que o Echo v4 já oferece.
* Implementar lógica de autenticação baseada em CORS (CORS não é autenticação).
* Criar listas brancas (whitelists) em arquivos JSON ou banco de dados (deve ser via ENV).
* Modificar o middleware de JWT ou Rate Limiting.
* Antecipar FASE 13.4 (Validação Reforçada).

#### ESTRATÉGIA DE IMPLEMENTAÇÃO RECOMENDADA

##### 1. Configuração no `config.go`

```go
type SecurityConfig struct {
    CORSAllowedOrigins []string `mapstructure:"cors_allowed_origins"`
    CORSAllowCredentials bool    `mapstructure:"cors_allow_credentials"`
    SecurityHeadersEnabled bool  `mapstructure:"security_headers_enabled"`
}

```

##### 2. Middleware de CORS no `cmd/main.go`

```go
e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
    AllowOrigins: cfg.Security.CORSAllowedOrigins,
    AllowMethods: []string{http.MethodGet, http.MethodPut, http.MethodPost, http.MethodDelete},
}))

```

#### TESTES OBRIGATÓRIOS

Criar `internal/api/middleware/security_test.go`:

* **Teste CORS**: Validar que requisições de origens não permitidas são bloqueadas.
* **Teste Headers**: Validar que os headers `X-Frame-Options` e `HSTS` estão presentes na resposta.

#### CRITÉRIO DE VALIDAÇÃO

A fase só é considerada concluída se:

1. Middleware CORS funcional e configurado via ENV. 


2. Headers de segurança presentes em todas as respostas HTTP. 


3. Build estático continua passando (`CGO_ENABLED=0`). 


4. Testes unitários de middleware aprovados. 



#### SAÍDA OBRIGATÓRIA

```
SESSION_LOG_START | Versão: v1.0.0 | Data: DD/MM/YYYY
- ARQUIVOS CRIADOS/MODIFICADOS:
  - internal/api/middleware/security_headers.go
  - internal/api/middleware/security_test.go
  - internal/infrastructure/config/config.go
  - cmd/main.go
  - docs/env_vars.md
  - docs/security_headers.md

- RESUMO TÉCNICO:
  - Middleware CORS implementado com suporte a múltiplas origens via ENV
  - Injeção de headers de segurança (HSTS, CSP, X-Frame-Options) concluída
  - Configuração centralizada no struct de SecurityConfig
  - Testes de validação de headers e Cross-Origin aprovados

- DÍVIDA TÉCNICA / PENDÊNCIAS:
  - CSP dinâmico por rota não implementado (usando política global)
  - Suporte a subdomínios via wildcard (regex) em CORS não implementado (apenas lista explícita)

- COMANDO DE VALIDAÇÃO:
  - CGO_ENABLED=0 GOOS=linux go build ./cmd/main.go
  - go test ./internal/api/middleware/security_test.go -v

- SUGESTÃO DE COMMIT:
  feat(fase-13.3): implement configurable CORS and security headers

SESSION_LOG_END

```

