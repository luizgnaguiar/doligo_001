 MODO DE EXECUÃ‡ÃƒO OBRIGATÃ“RIO

ANTES DE QUALQUER ANÃLISE OU GERAÃ‡ÃƒO DE SAÃDA:

VocÃª DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer aÃ§Ã£o que viole o contrato

HIERARQUIA DE PRECEDÃŠNCIA (OBRIGATÃ“RIA):
1. AGENT_CONTRACT.txt (autoridade mÃ¡xima)
2. EspecificaÃ§Ã£o abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceÃ§Ãµes.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ESPECIFICAÃ‡ÃƒO DA TAREFA
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 
 TÃ­tulo: EspecificaÃ§Ã£o de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de ProduÃ§Ã£o
  Papel: Atue como Arquiteto de Software SÃªnior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura tÃ©cnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrÃµes de Clean Architecture e as restriÃ§Ãµes de infraestrutura moderna.
  1. RestriÃ§Ãµes de CompilaÃ§Ã£o e Ambiente
  â€¢ BinÃ¡rio EstÃ¡tico: Proibido o uso de CGO. Toda a soluÃ§Ã£o deve compilar com CGO_ENABLED=0.
  â€¢ Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  â€¢ Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  â€¢ VersÃ£o do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  â€¢ Estrutura de Pastas: * /cmd: Entrypoints da aplicaÃ§Ã£o.
  â€¢ /internal/domain: Entidades puras e interfaces de repositÃ³rios/serviÃ§os.
  â€¢ /internal/usecase: OrquestraÃ§Ã£o da lÃ³gica de negÃ³cio.
  â€¢ /internal/infrastructure: ImplementaÃ§Ãµes de banco, drivers e serviÃ§os externos.
  â€¢ /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  â€¢ Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de DomÃ­nio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistÃªncia.
  â€¢ InjeÃ§Ã£o de DependÃªncia: ImplementaÃ§Ã£o via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. ConcorrÃªncia e ResiliÃªncia
  â€¢ GestÃ£o de Contexto: Todo mÃ©todo de Usecase e Repository deve aceitar context.Context.
  â€¢ Pessimistic Locking: OperaÃ§Ãµes crÃ­ticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condiÃ§Ãµes de corrida em ambiente distribuÃ­do.
  â€¢ Internal Task Runner: Implementar um Worker Pool baseado em channels.
  â€¢ Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente atÃ© um limite de 15 segundos.
  â€¢ Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  â€¢ Circuit Breaker: Implementar polÃ­tica de retries simples para envio de e-mails falhos.
  4. PersistÃªncia e IntegraÃ§Ãµes
  â€¢ ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatÃ³rios complexos.
  â€¢ Pool de ConexÃµes: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variÃ¡veis de ambiente.
  â€¢ MigraÃ§Ãµes: Utilizar golang-migrate/migrate embutido no binÃ¡rio.
  â€¢ Documentos: GeraÃ§Ã£o de PDF utilizando a biblioteca maroto (pure Go).
  5. SeguranÃ§a e Observabilidade
  â€¢ Auth: JWT Stateless. Middleware de RBAC validando permissÃµes por Claims.
  â€¢ Logs: Implementar estruturaÃ§Ã£o de logs via ZeroLog ou Zap com injeÃ§Ã£o de request_id no contexto.
  â€¢ Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste ObrigatÃ³rios (CritÃ©rios de Aceite)
  1. CT-01 (Portabilidade): O binÃ¡rio compilado deve rodar em uma imagem Docker scratch sem dependÃªncias de
  SO.
  2. CT-02 (ConcorrÃªncia): Validar que duas transaÃ§Ãµes simultÃ¢neas de dÃ©bito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexÃ£o pelo cliente interrompe a goroutine de
  geraÃ§Ã£o de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar apÃ³s um sinal de
  interrupÃ§Ã£o, sem perda de dados imediata.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
INÃCIO DA EXECUÃ‡ÃƒO
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

OBJETIVO DA FASE 11.1
Documentar todas as variÃ¡veis de ambiente atualmente utilizadas pelo sistema, garantindo que a aplicaÃ§Ã£o possa ser configurada e executada em ambiente de produÃ§Ã£o sem dependÃªncia de conhecimento implÃ­cito ou oral.
Esta fase NÃƒO INTRODUZ MUDANÃ‡AS TÃ‰CNICAS.
NATUREZA DA FASE
ğŸ“„ Puramente documental
ğŸ§± NÃ£o estrutural
ğŸš« NÃ£o bloqueia produÃ§Ã£o
ğŸ›‘ NÃ£o autoriza refatoraÃ§Ãµes
ESCOPO PERMITIDO (ÃšNICO)
Ã‰ permitido APENAS:
Identificar variÃ¡veis de ambiente jÃ¡ existentes no cÃ³digo
DocumentÃ¡-las de forma tÃ©cnica e objetiva
Criar ou atualizar documentaÃ§Ã£o em Markdown
ESCOPO PROIBIDO (ABSOLUTO)
Ã‰ EXPRESSAMENTE PROIBIDO nesta fase:
Criar novas variÃ¡veis de ambiente
Renomear variÃ¡veis existentes
Alterar valores default no cÃ³digo
Introduzir validaÃ§Ã£o de env vars
Alterar lÃ³gica de inicializaÃ§Ã£o
Criar .env, exemplos, scripts ou templates
Introduzir libs de config (Viper, envconfig, etc.)
Modificar qualquer arquivo .go
Qualquer necessidade percebida fora disso:
â¡ï¸ Registrar como DÃVIDA TÃ‰CNICA
FONTE DE VERDADE PARA O LEVANTAMENTO
As variÃ¡veis DEVEM ser levantadas EXCLUSIVAMENTE a partir de:
os.Getenv
os.LookupEnv
Leitura explÃ­cita de env vars no main
ConfiguraÃ§Ã£o jÃ¡ existente no runtime da aplicaÃ§Ã£o
âŒ Ã‰ proibido inferir variÃ¡veis â€œesperadasâ€, â€œpadrÃ£o de mercadoâ€ ou â€œprovÃ¡veisâ€.
ARTEFATO OBRIGATÃ“RIO
Criar exatamente um arquivo:
docs/env_vars.md
Nenhum outro arquivo documental Ã© permitido nesta fase.
FORMATO OBRIGATÃ“RIO DE CADA VARIÃVEL
Cada variÃ¡vel DEVE CONTER TODOS os campos abaixo:
Nome da variÃ¡vel
DescriÃ§Ã£o objetiva
Tipo esperado
Obrigatoriedade (obrigatÃ³ria / opcional)
Valor default (ou â€œnÃ£o definidoâ€)
Impacto se ausente ou invÃ¡lida
Linguagem obrigatÃ³ria:
TÃ©cnica
Declarativa
Factual
Sem linguagem prospectiva
Sem recomendaÃ§Ãµes
Sem sugestÃµes de melhoria
EXEMPLO DE TOM (REFERENCIAL)
DB_HOST
String. EndereÃ§o do servidor de banco de dados utilizado pela aplicaÃ§Ã£o.
ObrigatÃ³ria.
Valor default: nÃ£o definido.
A ausÃªncia impede a inicializaÃ§Ã£o da aplicaÃ§Ã£o.
(O conteÃºdo acima Ã© apenas ilustrativo.)
CRITÃ‰RIO DE CONCLUSÃƒO DA FASE
A FASE 11.1 Ã© considerada CONCLUÃDA quando:
docs/env_vars.md existe
Todas as env vars efetivamente usadas estÃ£o documentadas
Nenhum arquivo .go foi alterado
Nenhuma variÃ¡vel inexistente foi documentada
LOG OBRIGATÃ“RIO DA FASE
Ao final, gerar SESSION_LOG contendo:
Lista de arquivos criados/modificados
DeclaraÃ§Ã£o explÃ­cita de que:
Nenhuma variÃ¡vel nova foi criada
Nenhum cÃ³digo foi alterado
ConfirmaÃ§Ã£o de escopo respeitado
REGRA DE SEGURANÃ‡A FINAL
Se for identificado que:
O sistema depende de configuraÃ§Ã£o implÃ­cita
Ou de env var nÃ£o documentada no cÃ³digo
â¡ï¸ NÃƒO CORRIGIR
â¡ï¸ NÃƒO ALTERAR
â¡ï¸ REGISTRAR COMO DÃVIDA TÃ‰CNICA