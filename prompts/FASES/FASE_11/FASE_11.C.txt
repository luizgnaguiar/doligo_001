 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────

FASE 11.2 — Checklist Operacional de Produção (Pré-GoLive)
OBJETIVO DA FASE
Estabelecer um checklist mínimo e verificável para execução segura do sistema em ambientes de produção não massivos, cobrindo aspectos operacionais, de infraestrutura e execução real do binário.
Esta fase NÃO introduz código, NÃO altera arquitetura, NÃO cria requisitos funcionais e NÃO bloqueia produção.
Seu propósito é reduzir risco operacional e formalizar responsabilidades fora do código.
ESCOPO PERMITIDO (OBRIGATÓRIO)
1. Variáveis de Ambiente
Todas as variáveis de ambiente utilizadas pela aplicação DEVEM:
Estar documentadas em arquivo versionado (ex: docs/env.md, .env.example).
Conter descrição funcional clara (não apenas nome).
Indicar se são obrigatórias ou opcionais.
É PROIBIDO:
Introduzir novas variáveis de ambiente nesta fase.
Alterar lógica de leitura/configuração da aplicação.
2. Execução Real do Binário Linux
O binário DEVE ser executado ao menos uma vez em ambiente Linux real:
VM Linux
Container Linux
Pipeline CI Linux
A validação mínima consiste em:
Inicialização do processo
Conexão com banco
Inicialização do servidor HTTP
Compilação cruzada sem execução NÃO é suficiente.
3. Reverse Proxy / Gateway
O ambiente de produção DEVE possuir reverse proxy (nginx, traefik ou equivalente).
O timeout de requisição DEVE ser configurado explicitamente para:
≥ 30 segundos em rotas de geração de PDF.
A configuração pertence ao ambiente, não ao código.
4. Backup Automático de Banco de Dados
Deve existir:
Rotina automatizada de backup do banco.
Retenção mínima definida (ex: últimos N dias).
Não é exigido:
Snapshot transacional sofisticado.
Replicação.
A existência do backup é responsabilidade operacional, não do sistema.
5. Log Rotation no Host
O host de execução DEVE possuir:
Log rotation configurado (logrotate ou equivalente).
É PROIBIDO:
Implementar log rotation no código.
Alterar formato de logs existentes.
ESCOPO EXPLICITAMENTE PROIBIDO (REGRA CRÍTICA)
Nesta fase é TERMINANTEMENTE PROIBIDO:
Criar ou modificar código Go.
Criar novas fases técnicas.
Ajustar observabilidade, métricas ou tracing.
Introduzir ferramentas externas (APM, ELK, Prometheus, etc.).
Alterar main.go, handlers, usecases ou repositórios.
Criar scripts de infraestrutura dentro do repositório da aplicação.
Qualquer necessidade técnica identificada DEVE ser registrada como DÍVIDA TÉCNICA, nunca implementada nesta fase.
ARTEFATOS ESPERADOS
Checklist operacional preenchido (manual ou documentado).
Evidência de execução do binário em Linux (log, CI, ou anotação).
Documentação de variáveis de ambiente atualizada.
Nenhum commit de código obrigatório.
SESSION LOG (OBRIGATÓRIO)
Caso esta fase gere um log, ele DEVE:
Conter apenas documentação ou confirmação operacional.
Não listar arquivos de código.
Não declarar “produção pronta” de forma absoluta.
Não alterar status de fases anteriores.
Exemplo válido de resumo:
“Checklist operacional de produção executado. Nenhuma alteração de código realizada.”
CONDIÇÃO DE CONCLUSÃO DA FASE
A FASE 11.2 é considerada concluída quando:
Todos os itens do checklist forem explicitamente verificados ou aceitos.
Nenhuma alteração de código for realizada.
Nenhum escopo técnico adicional for introduzido.