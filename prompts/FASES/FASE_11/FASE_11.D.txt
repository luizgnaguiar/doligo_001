 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────

FASE 11.3 — RUNBOOK OPERACIONAL (INCIDENTES BÁSICOS)
CONTEXTO
Esta fase pertence ao GATE 2 — Robustez e Qualidade e tem caráter exclusivamente operacional e documental.
Seu objetivo é fornecer procedimentos humanos claros e determinísticos para resposta a incidentes básicos em ambiente de produção não massivo.
Esta fase NÃO introduz código, NÃO altera comportamento do sistema e NÃO adiciona dependências técnicas.
OBJETIVO DA FASE
Produzir um Runbook Operacional Básico, documentando passo a passo como um operador deve agir diante de incidentes comuns já conhecidos pelo desenho do sistema.
O resultado deve permitir que uma pessoa sem conhecimento profundo do código consiga:
Identificar o problema
Coletar evidências mínimas
Executar ações corretivas seguras
Saber quando escalar ou interromper a operação
ESCOPO PERMITIDO (OBRIGATÓRIO)
Esta fase PODE APENAS:
Criar documentação em docs/
Descrever procedimentos operacionais manuais
Referenciar capacidades já existentes no sistema (logs, métricas internas, endpoints)
Declarar explicitamente limites do que não pode ser resolvido operacionalmente
ESCOPO PROIBIDO (ABSOLUTO)
É EXPRESSAMENTE PROIBIDO nesta fase:
Alterar qualquer código Go
Criar novos endpoints
Criar scripts de automação
Introduzir ferramentas externas
Sugerir melhorias arquiteturais
Propor mudanças futuras
Implementar monitoramento, alertas ou retries adicionais
Qualquer violação INVALIDA A FASE.
INCIDENTES QUE DEVEM SER COBERTOS (MÍNIMO OBRIGATÓRIO)
O Runbook DEVE conter procedimentos claros para:
API não responde
Verificação de processo
Verificação de porta
Logs mínimos a coletar
Critério objetivo para restart
Erro na geração de PDF
Como identificar falha por logs
Como diferenciar erro de dados vs erro de execução
O que NÃO tentar corrigir manualmente
Falha no envio de e-mail
Comportamento esperado do circuit breaker
Como identificar breaker aberto
Quando aguardar vs quando intervir
Erro de banco de dados
Falha de conexão
Migração pendente
Ação segura permitida
Ação proibida
Lentidão geral
Uso de métricas internas existentes
Como diferenciar lentidão de PDF vs API geral
Critério de decisão operacional
FORMATO DO ARTEFATO (OBRIGATÓRIO)
Arquivo: docs/runbook_operacional.md
Linguagem: objetiva, imperativa, sem termos especulativos
Cada incidente deve conter:
Sintoma
Como detectar
Ação imediata
O que NÃO fazer
Quando escalar
CRITÉRIOS DE ACEITE (GATE 2 — FASE 11.3)
A fase é considerada CONCLUÍDA somente se:
Existe exatamente 1 arquivo novo em docs/
Nenhum arquivo fora de docs/ foi alterado
Todos os incidentes mínimos estão documentados
Não há linguagem futurista (“poderia”, “idealmente”, “em uma próxima fase”)
Não há sugestões de mudança de código ou arquitetura
O documento é operacional, não conceitual
LOG DA FASE (OBRIGATÓRIO)
Ao final, deve ser registrado:
SESSION_LOG_START
Lista de arquivos criados
Resumo técnico objetivo
Declaração explícita de ausência de código
Comando de validação: N/A (fase documental)
OBSERVAÇÃO FINAL (IMUTÁVEL)
Esta fase não melhora o sistema.
Ela formaliza como operar com segurança o sistema que já existe.
Nenhuma inteligência adicional deve ser inferida.