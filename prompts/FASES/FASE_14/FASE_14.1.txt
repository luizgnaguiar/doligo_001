 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────

TAREFA ATIVA — FASE 14.1
IMPLEMENTAÇÃO DE TRILHA DE AUDITORIA DE DOMÍNIO (PERSISTENTE)

CONTEXTO DE EXECUÇÃO

Após a blindagem da API no Grupo 13, o sistema precisa de memória histórica. Atualmente, se um utilizador alterar um stock ou apagar uma fatura, o registo existe apenas nos logs técnicos (slog). Esta fase introduz a persistência de eventos críticos para fins de conformidade e suporte ao cliente.

OBJETIVO ÚNICO DA TAREFA

Criar o domínio de Auditoria e implementar o registo automático de eventos de escrita (Create, Update, Delete) em entidades críticas no banco de dados.

ESCOPO AUTORIZADO

Você deve executar as seguintes ações:

Infraestrutura de Dados (Migration):

Criar uma nova migração SQL para a tabela audit_logs:

id (UUID, Primary Key)

timestamp (TIMESTAMPTZ)

user_id (UUID, Foreign Key para users)

resource_name (string - ex: "item", "stock", "invoice")

resource_id (string - o ID da entidade afetada)

action (string - ex: "CREATE", "UPDATE", "DELETE")

old_values (JSONB/JSON - estado anterior)

new_values (JSONB/JSON - novo estado)

correlation_id (string - para ligar ao log técnico)

Camada de Domínio (Audit Domain):

Criar a entidade AuditLog no diretório de domínio.

Definir a interface AuditRepository.

Implementação de Serviço de Auditoria:

Criar um serviço no internal/usecase ou internal/infrastructure que receba eventos de auditoria e os persista de forma assíncrona (via goroutine) para não onerar o tempo de resposta da API principal.

Integração nos Usecases Críticos:

Integrar o serviço de auditoria nos seguintes fluxos:

Stock: Registo de cada movimentação (entrada/saída).

Item: Registo de alteração de preços ou descrições.

Identity: Registo de logins (opcional) e alterações de permissões.

RESTRIÇÕES ABSOLUTAS

PROIBIDO utilizar bibliotecas externas de "Audit Hook" que façam reflexão profunda automática em todas as tabelas (deve ser explícito).

PROIBIDO bloquear a transação principal do banco de dados para escrever o log de auditoria (usar o padrão fire-and-forget ou garantir que a falha na auditoria não cancele a venda).

PROIBIDO expor endpoints de leitura de Auditoria nesta fase (foco apenas na escrita).

TESTES OBRIGATÓRIOS

CT-AUDIT-01: Validar que, ao atualizar um stock, um registo correspondente aparece na tabela audit_logs.

CT-AUDIT-02: Validar que o user_id e o correlation_id estão corretamente preenchidos no registo de auditoria.

CRITÉRIO DE VALIDAÇÃO

Tabela audit_logs criada e migrada com sucesso.

Serviço de auditoria integrado e funcional sem degradar a performance da API.

CGO_ENABLED=0 GOOS=linux go build ./cmd/main.go concluído com sucesso.

SAÍDA OBRIGATÓRIA

SESSION_LOG_START | Versão: v1.2.0 | Data: DD/MM/YYYY
- ARQUIVOS CRIADOS/MODIFICADOS:
  - internal/infrastructure/migrations/0000XX_create_audit_logs.up.sql
  - internal/domain/audit.go
  - internal/usecase/audit_service.go
  - internal/usecase/stock_usecase.go (ou similar)
  - internal/infrastructure/db/audit_repository.go

- RESUMO TÉCNICO:
  - Implementada trilha de auditoria persistente para eventos de domínio.
  - Criado mecanismo assíncrono de captura de logs para evitar latência na API.
  - Mapeadas ações de Auditoria para Stock e Itens com suporte a JSON para diferenciação de estados (Old/New).
  - Vinculação técnica entre logs de auditoria e logs de aplicação via correlation_id.

- DÍVIDA TÉCNICA / PENDÊNCIAS:
  - Implementar visualização da trilha de auditoria no dashboard (Fase futura).
  - Política de purga/arquivamento de logs de auditoria antigos.

- COMANDO DE VALIDAÇÃO:
  - CGO_ENABLED=0 GOOS=linux go build ./cmd/main.go
  - go test ./internal/usecase/audit_test.go -v

- SUGESTÃO DE COMMIT:
  feat(fase-14.1): implement persistent domain audit trail

SESSION_LOG_END