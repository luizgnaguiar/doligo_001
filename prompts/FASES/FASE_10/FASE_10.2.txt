 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────

TAREFA ATIVA — FASE 10.2
BOM UPDATE ROBUSTO (GATE 2)
CONTEXTO DE EXECUÇÃO
Esta tarefa ocorre após o encerramento formal das FASES 10.1 e 10.1.1.
O sistema já possui:
Domínio de BOM existente
Usecase de BOM existente
Persistência via GORM
Testes unitários parciais
O objetivo não é criar um novo BOM, mas tornar a atualização de BOM explícita, previsível e robusta.
OBJETIVO ÚNICO DA TAREFA
Eliminar qualquer dependência implícita de FullSaveAssociations ou comportamento automático do ORM na atualização de BOM.
A atualização de uma BOM deve passar a ser explícita, com operações claras de:
ADD (inclusão de itens)
REMOVE (remoção de itens)
MODIFY (alteração de quantidade, ordem ou propriedades)
Nada além disso.
PROBLEMA A SER RESOLVIDO
Atualmente, a atualização de BOM:
Depende de comportamento implícito do ORM
Não diferencia semanticamente add / remove / update
Pode gerar efeitos colaterais silenciosos
Dificulta auditoria, testes e raciocínio transacional
Esta fase corrige exclusivamente isso.
ESCOPO AUTORIZADO
Você pode somente:
Ajustar o usecase de BOM
Ajustar DTOs de entrada, se necessário
Ajustar repositórios de BOM, se estritamente necessário
Ajustar mapeamento de entidades, se indispensável
Sempre mantendo:
Clean Architecture
Separação de responsabilidades
Controle transacional explícito
REGRAS OBRIGATÓRIAS DE IMPLEMENTAÇÃO
1. Atualização Explícita
A atualização de BOM deve:
Identificar claramente:
Itens novos
Itens removidos
Itens existentes modificados
Executar cada operação de forma explícita
Não depender de cascata implícita do ORM
2. Transação Clara
Toda operação de update de BOM deve:
Ser executada dentro de uma única transação
Garantir atomicidade
Falhar integralmente em caso de erro
3. Sem FullSaveAssociations
É explicitamente proibido:
Usar FullSaveAssociations
Confiar em Save(&entity) para sincronizar coleções
Depender de comportamento automático do GORM para filhos
4. Sem Efeitos Colaterais
Não é permitido:
Reordenar itens sem intenção explícita
Recriar registros existentes
Apagar e reinserir tudo como atalho
Alterar comportamento fora do update de BOM
RESTRIÇÕES ABSOLUTAS
Nesta fase, NÃO é permitido:
Criar novos domínios
Alterar regras de negócio do BOM
Alterar APIs públicas não relacionadas a update
Introduzir novas dependências
Criar lógica genérica reutilizável
Antecipar FASE 10.3 ou 10.4
Refatorar código não diretamente relacionado
Ajustar testes que não sejam estritamente necessários
Se algo parecer necessário mas fugir do escopo:
→ registrar como DÍVIDA TÉCNICA
→ não implementar
CRITÉRIO DE VALIDAÇÃO
A fase só é considerada concluída se:
CGO_ENABLED=0 GOOS=linux go build ./cmd/main.go
for executado com sucesso.
Testes adicionais são desejáveis, mas não obrigatórios nesta fase.
SAÍDA OBRIGATÓRIA
Ao final, gerar um SESSION_LOG contendo:
Arquivos criados/modificados
Resumo técnico objetivo
Declaração explícita de:
ausência de FullSaveAssociations
atualização explícita ADD / REMOVE / MODIFY
Dívidas técnicas (se houver)
Comando de validação executado
REGRA DE CONTENÇÃO DE ESCOPO
Se houver qualquer dúvida entre:
“tornar o update mais inteligente”
“simplificar usando o ORM”
“deixar implícito”
A resposta correta é NÃO FAZER.
CONDIÇÃO DE ENCERRAMENTO
Após esta tarefa:
A FASE 10.2 estará ENCERRADA
O projeto poderá avançar para a FASE 10.3 — Produção com Bin Explícito
Nenhuma ação adicional é permitida após a entrega.