 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────

## TAREFA ATIVA — FASE 12.3
### ESTRATÉGIA DE BACKUP DE BANCO DE DADOS (DOCUMENTAÇÃO TÉCNICA)

#### CONTEXTO DE EXECUÇÃO
Esta tarefa ocorre após o encerramento formal da FASE 12.2 (Timeout de Reverse Proxy).

O sistema já possui:
- Documentação de variáveis de ambiente
- Documentação de timeouts de proxy
- Persistência via GORM com PostgreSQL/MySQL
- Migrações versionadas via `golang-migrate`
- Dados transacionais críticos (estoque, BOM, faturas)

O objetivo não é implementar automação de backup, mas **definir uma estratégia mínima** documentada e reproduzível para proteção de dados em ambientes não massivos.

#### OBJETIVO ÚNICO DA TAREFA
Criar documentação técnica clara sobre **estratégia mínima de backup** para o banco de dados, definindo tipo, frequência, retenção e procedimentos de recuperação básicos.

Nada além disso.

#### PROBLEMA A SER RESOLVIDO
Atualmente:
- Não há estratégia documentada de backup
- Operadores não sabem qual tipo de backup fazer
- Frequência e retenção não estão definidas
- Procedimento de recuperação não está documentado
- Risco de perda de dados não está mitigado

Esta fase corrige **exclusivamente** isso.

#### ESCOPO AUTORIZADO
Você pode somente:
1. **Definir** estratégia mínima de backup adequada para:
   - Banco único (PostgreSQL ou MySQL)
   - Ambiente único (não multi-região)
   - Volume pequeno/médio (não massivo)
2. **Documentar** procedimentos usando ferramentas nativas:
   - PostgreSQL: `pg_dump`, `pg_restore`
   - MySQL: `mysqldump`, `mysql`
3. **Especificar**:
   - Tipo de backup (full/incremental)
   - Frequência recomendada
   - Retenção sugerida
   - Local de armazenamento
4. **Fornecer** exemplos de comandos reproduzíveis

#### RESTRIÇÕES ABSOLUTAS
Nesta fase, **NÃO** é permitido:
- Implementar scripts automáticos de backup
- Integrar com provedores cloud (AWS S3, GCP, Azure)
- Criar jobs de cron ou systemd timers
- Versionar dumps reais no repositório
- Implementar restauração automatizada
- Configurar réplicas ou standby servers
- Criar ferramentas de monitoramento de backup
- Antecipar FASE 12.4 ou posteriores

Se algo parecer necessário mas fugir do escopo:  
→ **registrar como DÍVIDA TÉCNICA**  
→ **não implementar**

#### FORMATO OBRIGATÓRIO DO DOCUMENTO
O arquivo `docs/backup_strategy.md` **DEVE** seguir este template:

```markdown
# Estratégia de Backup de Banco de Dados

**Versão**: 1.0.0  
**Data**: YYYY-MM-DD  
**Escopo**: Ambiente único, banco único, volume pequeno/médio

---

## 1. Contexto e Premissas

### Escopo da Estratégia
- **Tipo de Backup**: Full (completo)
- **Banco Suportado**: PostgreSQL E MySQL
- **Ambiente**: Produção single-instance
- **Volume Estimado**: Até 100GB (ajustável)

### O que ESTÁ Coberto
- Backup de schema e dados
- Retenção de versões históricas
- Procedimento de restauração manual

### O que NÃO Está Coberto
- Backup incremental/diferencial
- Replicação em tempo real
- Multi-região ou disaster recovery
- Automação via CI/CD
- Monitoramento de sucesso de backup

---

## 2. Estratégia Definida

### Tipo de Backup
**Full Backup** (backup completo de schema + dados)

**Justificativa**:
- Simplicidade operacional
- Recuperação previsível
- Adequado para volumes não massivos
- Compatível com ferramentas nativas

### Frequência Recomendada
- **Diária**: 1x por dia (00:00 UTC ou horário de menor carga)
- **Semanal** (opcional): Backup adicional aos domingos para retenção longa

### Retenção Sugerida
- **Backups diários**: 7 dias (última semana)
- **Backups semanais**: 4 semanas (último mês)
- **Total de armazenamento**: ~11 backups simultâneos

### Local de Armazenamento
- **Primário**: Sistema de arquivos local seguro (fora do diretório da aplicação)
- **Recomendado**: Volume persistente montado (ex: `/backup` ou `/mnt/backup`)
- **Ideal** (fora de escopo desta fase): Cópia para storage externo (S3, NFS, etc.)

---

## 3. Procedimentos PostgreSQL

### Backup Completo

```bash
# Variáveis de ambiente (definir antes)
export PGHOST=localhost
export PGPORT=5432
export PGDATABASE=doligo_db
export PGUSER=doligo_user
export PGPASSWORD=senha_segura

# Executar backup
BACKUP_FILE="/backup/doligo_$(date +%Y%m%d_%H%M%S).sql.gz"
pg_dump --format=plain --no-owner --no-acl | gzip > "$BACKUP_FILE"

# Verificar sucesso
if [ $? -eq 0 ]; then
    echo "Backup criado: $BACKUP_FILE"
else
    echo "ERRO: Falha no backup"
    exit 1
fi
```

### Restauração

```bash
# Identificar arquivo de backup
BACKUP_FILE="/backup/doligo_20260203_000000.sql.gz"

# ATENÇÃO: Este comando SOBRESCREVE o banco existente
# Certifique-se de ter backup do estado atual antes de restaurar

# Restaurar
gunzip -c "$BACKUP_FILE" | psql -d doligo_db

# Verificar integridade
psql -d doligo_db -c "SELECT COUNT(*) FROM users;"
```

### Rotação de Backups (Manual)

```bash
# Manter apenas últimos 7 dias
find /backup -name "doligo_*.sql.gz" -mtime +7 -delete
```

---

## 4. Procedimentos MySQL

### Backup Completo

```bash
# Variáveis de ambiente (definir antes)
export MYSQL_HOST=localhost
export MYSQL_PORT=3306
export MYSQL_DATABASE=doligo_db
export MYSQL_USER=doligo_user
export MYSQL_PASSWORD=senha_segura

# Executar backup
BACKUP_FILE="/backup/doligo_$(date +%Y%m%d_%H%M%S).sql.gz"
mysqldump --single-transaction --routines --triggers --events \
    -h "$MYSQL_HOST" -P "$MYSQL_PORT" \
    -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" \
    "$MYSQL_DATABASE" | gzip > "$BACKUP_FILE"

# Verificar sucesso
if [ $? -eq 0 ]; then
    echo "Backup criado: $BACKUP_FILE"
else
    echo "ERRO: Falha no backup"
    exit 1
fi
```

### Restauração

```bash
# Identificar arquivo de backup
BACKUP_FILE="/backup/doligo_20260203_000000.sql.gz"

# ATENÇÃO: Este comando SOBRESCREVE o banco existente
# Certifique-se de ter backup do estado atual antes de restaurar

# Restaurar
gunzip -c "$BACKUP_FILE" | mysql -h "$MYSQL_HOST" -P "$MYSQL_PORT" \
    -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" "$MYSQL_DATABASE"

# Verificar integridade
mysql -h "$MYSQL_HOST" -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" \
    -e "SELECT COUNT(*) FROM users;" "$MYSQL_DATABASE"
```

### Rotação de Backups (Manual)

```bash
# Manter apenas últimos 7 dias
find /backup -name "doligo_*.sql.gz" -mtime +7 -delete
```

---

## 5. Checklist de Execução

### Antes do Primeiro Backup
- [ ] Criar diretório `/backup` com permissões adequadas (`chmod 700`)
- [ ] Verificar espaço em disco disponível (mínimo 2x tamanho do banco)
- [ ] Testar credenciais de acesso ao banco
- [ ] Executar backup de teste e validar restauração

### Rotina Diária
- [ ] Executar comando de backup conforme procedimento
- [ ] Verificar criação do arquivo `.sql.gz`
- [ ] Validar tamanho do arquivo (não deve ser 0 bytes)
- [ ] Registrar sucesso/falha em log operacional

### Rotina Semanal
- [ ] Executar rotação de backups antigos
- [ ] Verificar espaço em disco restante
- [ ] Testar restauração de um backup aleatório (validação)

---

## 6. Recuperação de Desastres (Básico)

### Cenário 1: Corrupção de Dados Recente
1. Identificar backup mais recente anterior à corrupção
2. Parar a aplicação (`systemctl stop doligo` ou equivalente)
3. Executar restauração conforme procedimento
4. Validar integridade dos dados críticos
5. Reiniciar aplicação
6. Monitorar logs de erro

### Cenário 2: Perda Total do Banco
1. Recriar banco vazio com credenciais corretas
2. Executar migrações (se necessário): `golang-migrate up`
3. Executar restauração do backup mais recente
4. Validar schema e dados
5. Reiniciar aplicação

---

## 7. Limitações e Riscos Conhecidos

### Limitações da Estratégia
- **Ponto de recuperação**: Até 24h de perda de dados (backup diário)
- **Tempo de recuperação**: Proporcional ao tamanho do banco (não otimizado)
- **Sem automação**: Dependente de execução manual ou cron externo
- **Sem validação automática**: Integridade dos backups não é verificada automaticamente

### Riscos Aceitos
- Backup armazenado localmente (sem redundância geográfica)
- Falha de backup pode passar despercebida sem monitoramento
- Restauração não testada regularmente pode falhar quando necessária

### Quando Revisar Esta Estratégia
- Volume de dados ultrapassar 100GB
- RTO (Recovery Time Objective) exigir < 1 hora
- RPO (Recovery Point Objective) exigir < 24 horas
- Necessidade de multi-região ou disaster recovery

---

## 8. Próximos Passos (Fora de Escopo)

Melhorias futuras não implementadas nesta fase:
- Automação via `cron` ou `systemd.timer`
- Upload para storage externo (S3, GCS, Azure Blob)
- Notificação de sucesso/falha via e-mail ou webhook
- Validação automática de integridade de backups
- Backup incremental para redução de espaço

---

**Documento produzido em conformidade com FASE 12.3**  
**Nenhum script automático foi criado**  
**Nenhuma integração cloud foi implementada**
```

#### REGRAS DE DOCUMENTAÇÃO
Cada procedimento **DEVE**:
1. Ser reproduzível manualmente
2. Usar apenas ferramentas nativas do banco
3. Ter comandos válidos e testáveis
4. Incluir verificação de sucesso
5. Documentar limitações conhecidas

É **PROIBIDO**:
- Criar scripts prontos em `scripts/`
- Configurar cron jobs
- Integrar com serviços externos
- Implementar monitoramento
- Versionar dumps reais

#### CRITÉRIO DE VALIDAÇÃO
A fase só é considerada concluída se:

1. O arquivo `docs/backup_strategy.md` existe
2. Contém procedimentos para PostgreSQL E MySQL
3. Comandos são reproduzíveis manualmente
4. Nenhum arquivo `.go` foi modificado
5. Nenhum script real foi criado em `scripts/`

**Comando de validação**:
```bash
# Verificar que nenhum arquivo Go foi modificado
git diff --name-only | grep -E '\.go$' && echo "FALHA: Arquivo Go modificado" || echo "OK"

# Verificar que nenhum script foi criado
test -d scripts && echo "FALHA: Diretório scripts/ criado" || echo "OK"

# Verificar existência do documento
test -f docs/backup_strategy.md && echo "OK: Documento existe" || echo "FALHA: Documento ausente"
```

#### SAÍDA OBRIGATÓRIA
Ao final, gerar um **SESSION_LOG** contendo:

```
SESSION_LOG_START | Versão: v1.0.0 | Data: DD/MM/YYYY
- ARQUIVOS CRIADOS/MODIFICADOS:
  - docs/backup_strategy.md

- RESUMO TÉCNICO:
  - Estratégia de backup full definida (tipo, frequência, retenção)
  - Procedimentos documentados para PostgreSQL e MySQL
  - Comandos de backup e restauração validados como reproduzíveis
  - Checklist de execução e cenários de recuperação incluídos
  - Nenhuma automação ou integração foi implementada

- DÍVIDA TÉCNICA / PENDÊNCIAS:
  - Automação de backup via cron/systemd não implementada
  - Validação automática de integridade de backups não implementada
  - Integração com storage externo não implementada

- COMANDO DE VALIDAÇÃO:
  - test -f docs/backup_strategy.md
  - git diff --name-only | grep -E '\.(go|sh|yml)$'

SESSION_LOG_END
```

#### REGRA DE CONTENÇÃO DE ESCOPO
Se houver qualquer dúvida entre:
- "criar automação completa de backup"
- "apenas documentar procedimento manual"

A resposta correta é: **APENAS DOCUMENTAR PROCEDIMENTO MANUAL**.

#### CONDIÇÃO DE ENCERRAMENTO
Após esta tarefa:
- A **FASE 12.3** estará **ENCERRADA**
- O projeto poderá avançar para a **FASE 12.4** — Execução em Ambiente Linux Real
- Nenhuma ação adicional é permitida após a entrega

---

**DECLARAÇÃO FINAL DE ESCOPO**:  
Esta fase é **exclusivamente documental**.  
Nenhum script será criado.  
Nenhuma automação será implementada.  
Nenhuma integração cloud será realizada.