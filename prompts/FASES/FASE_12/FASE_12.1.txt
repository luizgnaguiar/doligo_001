 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────


## TAREFA ATIVA — FASE 12.1
### VARIÁVEIS DE AMBIENTE DOCUMENTADAS (GATE 2)

#### CONTEXTO DE EXECUÇÃO
Esta tarefa ocorre após o encerramento formal da FASE 11.D (Runbook Operacional).

O sistema já possui:
- Configuração via Viper lendo variáveis de ambiente
- Múltiplos módulos consumindo configurações
- Documentação operacional básica
- Checklists de pré-produção

O objetivo não é modificar o sistema de configuração, mas **documentar explicitamente** todas as variáveis consumidas pelo código.

#### OBJETIVO ÚNICO DA TAREFA
Criar documentação técnica completa e versionada de **todas** as variáveis de ambiente utilizadas pela aplicação, garantindo rastreabilidade, auditabilidade e facilidade de configuração em ambientes de produção.

Nada além disso.

#### PROBLEMA A SER RESOLVIDO
Atualmente:
- Variáveis de ambiente existem espalhadas no código
- Não há inventário centralizado
- Valores default não são explícitos
- Impacto de ausência não é documentado
- Operadores não têm referência confiável

Esta fase corrige **exclusivamente** isso.

#### ESCOPO AUTORIZADO
Você pode somente:
1. **Analisar** o arquivo `internal/infrastructure/config/config.go`
2. **Extrair** todas as variáveis lidas via Viper ou `os.Getenv`
3. **Criar** o arquivo `docs/env_vars.md`
4. **Documentar** cada variável conforme template obrigatório

#### RESTRIÇÕES ABSOLUTAS
Nesta fase, **NÃO** é permitido:
- Criar novas variáveis de ambiente
- Modificar `config.go` ou qualquer arquivo `.go`
- Alterar valores default no código
- Refatorar sistema de configuração
- Introduzir validações adicionais
- Criar scripts de geração automática
- Antecipar FASE 12.2 ou posteriores

Se algo parecer necessário mas fugir do escopo:  
→ **registrar como DÍVIDA TÉCNICA**  
→ **não implementar**

#### FORMATO OBRIGATÓRIO DO DOCUMENTO
O arquivo `docs/env_vars.md` **DEVE** seguir este template:

```markdown
# Variáveis de Ambiente

**Versão**: 1.0.0  
**Data**: YYYY-MM-DD  
**Escopo**: Aplicação completa

---

## 1. [NOME_DA_VARIAVEL]

- **Descrição**: [Descrição objetiva do propósito]
- **Tipo**: [string | int | bool | duration]
- **Obrigatório**: [SIM | NÃO]
- **Valor Default**: [valor ou "N/A"]
- **Impacto se Ausente**: [Descrição factual do comportamento]
- **Exemplo**:
  ```
  [NOME_DA_VARIAVEL]=[valor_exemplo]
  ```

---

[Repetir para cada variável identificada]
```

#### REGRAS DE DOCUMENTAÇÃO
Cada variável documentada **DEVE**:
1. Ter nome exato conforme aparece no código
2. Ter descrição objetiva (máximo 2 linhas)
3. Ter tipo explícito
4. Declarar obrigatoriedade de forma binária (SIM/NÃO)
5. Especificar valor default real ou declarar "N/A"
6. Descrever impacto factual da ausência (sem especulação)

É **PROIBIDO**:
- Usar linguagem vaga ("pode", "talvez", "geralmente")
- Inventar valores default não presentes no código
- Assumir comportamento não verificável
- Recomendar valores sem evidência
- Criar seções de "boas práticas"

#### CRITÉRIO DE VALIDAÇÃO
A fase só é considerada concluída se:

1. O arquivo `docs/env_vars.md` existe
2. Todas as variáveis de `config.go` estão documentadas
3. Nenhum arquivo `.go` foi modificado
4. O formato segue rigorosamente o template
5. Não há variáveis inventadas ou especulativas

**Comando de validação**:
```bash
# Verificar que nenhum arquivo Go foi modificado
git diff --name-only | grep -E '\.go$' && echo "FALHA: Arquivo Go modificado" || echo "OK"

# Verificar existência do documento
test -f docs/env_vars.md && echo "OK: Documento existe" || echo "FALHA: Documento ausente"
```

#### SAÍDA OBRIGATÓRIA
Ao final, gerar um **SESSION_LOG** contendo:

```
SESSION_LOG_START | Versão: v1.0.0 | Data: DD/MM/YYYY
- ARQUIVOS CRIADOS/MODIFICADOS:
  - docs/env_vars.md

- RESUMO TÉCNICO:
  - Inventário completo de [N] variáveis de ambiente extraído de config.go
  - Documentação estruturada criada seguindo template obrigatório
  - Nenhuma modificação de código foi realizada

- DÍVIDA TÉCNICA / PENDÊNCIAS:
  [Listar apenas se houver variáveis não documentáveis sem análise de código adicional]

- COMANDO DE VALIDAÇÃO:
  - test -f docs/env_vars.md
  - git diff --name-only | grep -E '\.go$'

SESSION_LOG_END
```

#### REGRA DE CONTENÇÃO DE ESCOPO
Se houver qualquer dúvida entre:
- "melhorar o sistema de configuração"
- "apenas documentar o que existe"

A resposta correta é: **APENAS DOCUMENTAR O QUE EXISTE**.

#### CONDIÇÃO DE ENCERRAMENTO
Após esta tarefa:
- A **FASE 12.1** estará **ENCERRADA**
- O projeto poderá avançar para a **FASE 12.2** — Timeout de Reverse Proxy
- Nenhuma ação adicional é permitida após a entrega

---

**DECLARAÇÃO FINAL DE ESCOPO**:  
Esta fase é **exclusivamente documental**.  
Nenhuma linha de código Go será alterada.  
Nenhuma variável será criada.  
Nenhuma refatoração será realizada.