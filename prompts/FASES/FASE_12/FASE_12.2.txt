
 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────


## TAREFA ATIVA — FASE 12.2
### TIMEOUT DE REVERSE PROXY (DOCUMENTAÇÃO TÉCNICA)

#### CONTEXTO DE EXECUÇÃO
Esta tarefa ocorre após o encerramento formal da FASE 12.1 (Variáveis de Ambiente Documentadas).

O sistema já possui:
- Documentação completa de variáveis de ambiente
- Endpoints de geração de PDF (potencialmente longos)
- Operações transacionais de produção (BOM)
- Consultas de margem com agregações SQL

O objetivo não é configurar proxies reais, mas **documentar tecnicamente** os requisitos mínimos de timeout para evitar interrupções prematuras de operações legítimas.

#### OBJETIVO ÚNICO DA TAREFA
Criar documentação técnica clara e reproduzível sobre **valores mínimos recomendados** de timeout para reverse proxies, baseando-se exclusivamente em operações conhecidas do sistema.

Nada além disso.

#### PROBLEMA A SER RESOLVIDO
Atualmente:
- Proxies reversos (Nginx, Traefik, etc.) podem ter timeouts default de 60s
- Geração de PDF de faturas complexas pode exceder esse limite
- Relatórios de margem com grandes volumes podem demorar
- Não há documentação sobre valores seguros
- Operadores configuram de forma arbitrária

Esta fase corrige **exclusivamente** isso.

#### ESCOPO AUTORIZADO
Você pode somente:
1. **Analisar** endpoints existentes que executam operações longas
2. **Identificar** operações conhecidas potencialmente demoradas:
   - Geração de PDF (`/api/v1/invoices/:id/pdf`)
   - Relatórios de margem (`/api/v1/margin`)
   - Produção de BOM (se exposta via API)
3. **Documentar** valores mínimos seguros baseados em:
   - Timeout de contexto já implementado (30s para PDF)
   - Operações transacionais observadas
   - Margem de segurança técnica
4. **Fornecer exemplos** de configuração para:
   - Nginx
   - Traefik (ou outro proxy moderno)

#### RESTRIÇÕES ABSOLUTAS
Nesta fase, **NÃO** é permitido:
- Criar arquivos reais de configuração de proxy
- Modificar timeouts no código Go
- Implementar retry logic
- Alterar endpoints existentes
- Criar novos middlewares
- Realizar benchmarks ou testes de carga
- Introduzir otimizações de performance
- Antecipar FASE 12.3 ou posteriores

Se algo parecer necessário mas fugir do escopo:  
→ **registrar como DÍVIDA TÉCNICA**  
→ **não implementar**

#### FORMATO OBRIGATÓRIO DO DOCUMENTO
O arquivo `docs/reverse_proxy_timeouts.md` **DEVE** seguir este template:

```markdown
# Configuração de Timeout para Reverse Proxy

**Versão**: 1.0.0  
**Data**: YYYY-MM-DD  
**Escopo**: Recomendações técnicas para produção

---

## 1. Contexto Técnico

Este documento define valores mínimos de timeout para reverse proxies baseando-se em operações longas conhecidas da aplicação.

### Operações Longas Identificadas

| Endpoint | Operação | Timeout Interno (Go) | Timeout Mínimo Recomendado (Proxy) |
|----------|----------|----------------------|-------------------------------------|
| `/api/v1/invoices/:id/pdf` | Geração de PDF | 30s | 45s |
| `/api/v1/margin` | Agregação SQL | N/A | 60s |
| [outros endpoints] | [descrição] | [valor] | [valor] |

**Justificativa dos Valores**:
- PDF: 30s (código) + 15s (margem de rede/handshake) = 45s
- Margin: Agregações complexas sem timeout explícito = 60s conservador

---

## 2. Nginx

### Configuração Mínima Recomendada

```nginx
location /api/v1/invoices/ {
    proxy_pass http://backend;
    proxy_read_timeout 45s;
    proxy_connect_timeout 10s;
    proxy_send_timeout 10s;
}

location /api/v1/margin {
    proxy_pass http://backend;
    proxy_read_timeout 60s;
    proxy_connect_timeout 10s;
    proxy_send_timeout 10s;
}

# Configuração global alternativa (menos granular)
proxy_read_timeout 60s;
```

**Parâmetros Críticos**:
- `proxy_read_timeout`: Tempo máximo aguardando resposta do backend
- `proxy_connect_timeout`: Tempo máximo para estabelecer conexão
- `proxy_send_timeout`: Tempo máximo para enviar request ao backend

---

## 3. Traefik

### Configuração via Labels (Docker)

```yaml
labels:
  - "traefik.http.routers.app.rule=Host(`exemplo.com`)"
  - "traefik.http.services.app.loadbalancer.server.port=8080"
  - "traefik.http.services.app.loadbalancer.responseForwarding.flushInterval=100ms"
  - "traefik.http.middlewares.timeout.forwardAuth.address=http://backend"
  - "traefik.http.middlewares.timeout.forwardAuth.timeout=60s"
```

### Configuração via Arquivo (traefik.yml)

```yaml
http:
  services:
    app:
      loadBalancer:
        servers:
          - url: "http://backend:8080"
        responseForwarding:
          flushInterval: "100ms"
  
  middlewares:
    timeout:
      buffering:
        maxRequestBodyBytes: 10485760  # 10MB
        maxResponseBodyBytes: 52428800  # 50MB
```

**Nota**: Traefik usa timeouts de transporte HTTP do Go. Valores devem ser ajustados via configuração de `serversTransport`.

---

## 4. Restrições e Avisos

### O que NÃO está incluído
- Benchmarks de performance
- Configuração de cache
- Otimização de throughput
- Rate limiting
- Circuit breakers no proxy

### Riscos Conhecidos Aceitos
- Valores baseados em análise estática, não em carga real
- Ambientes de produção podem exigir ajustes específicos
- Faturas com +1000 itens podem exceder 30s de geração

### Quando Revisar
- Após incidentes de timeout em produção
- Ao adicionar novos endpoints de operações longas
- Mudanças em volume de dados processados

---

## 5. Validação

Para verificar se os timeouts estão adequados:

```bash
# Simular request longo (requer curl e backend rodando)
time curl -X GET http://localhost/api/v1/margin?startDate=2020-01-01&endDate=2024-12-31

# Verificar logs do proxy para identificar timeouts
# Nginx: /var/log/nginx/error.log
# Traefik: stdout do container
```

Se `504 Gateway Timeout` ocorrer antes do tempo esperado, aumentar `proxy_read_timeout`.

---

**Documento produzido em conformidade com FASE 12.2**  
**Nenhuma configuração real foi aplicada**
```

#### REGRAS DE DOCUMENTAÇÃO
Cada recomendação de timeout **DEVE**:
1. Ter justificativa técnica baseada em código existente
2. Incluir margem de segurança explícita
3. Ser conservadora (evitar valores muito apertados)
4. Ser reproduzível (operador deve poder aplicar diretamente)

É **PROIBIDO**:
- Recomendar valores sem análise de código
- Criar configurações "otimizadas" sem evidência
- Incluir tuning de performance avançado
- Assumir comportamento de produção não observado
- Fornecer scripts de automação de configuração

#### CRITÉRIO DE VALIDAÇÃO
A fase só é considerada concluída se:

1. O arquivo `docs/reverse_proxy_timeouts.md` existe
2. Contém exemplos válidos de Nginx E Traefik (ou outro proxy moderno)
3. Valores recomendados têm justificativa técnica
4. Nenhum arquivo `.go` foi modificado
5. Nenhum arquivo de configuração real foi criado (`.conf`, `.yml`)

**Comando de validação**:
```bash
# Verificar que nenhum arquivo Go foi modificado
git diff --name-only | grep -E '\.go$' && echo "FALHA: Arquivo Go modificado" || echo "OK"

# Verificar que nenhum arquivo de config real foi criado
git diff --name-only | grep -E '\.(conf|yml|yaml)$' && echo "FALHA: Config real criado" || echo "OK"

# Verificar existência do documento
test -f docs/reverse_proxy_timeouts.md && echo "OK: Documento existe" || echo "FALHA: Documento ausente"
```

#### SAÍDA OBRIGATÓRIA
Ao final, gerar um **SESSION_LOG** contendo:

```
SESSION_LOG_START | Versão: v1.0.0 | Data: DD/MM/YYYY
- ARQUIVOS CRIADOS/MODIFICADOS:
  - docs/reverse_proxy_timeouts.md

- RESUMO TÉCNICO:
  - Análise de [N] endpoints com operações longas
  - Valores mínimos de timeout documentados com justificativa técnica
  - Exemplos de configuração fornecidos para Nginx e Traefik
  - Nenhuma modificação de código ou configuração real foi realizada

- DÍVIDA TÉCNICA / PENDÊNCIAS:
  [Listar apenas se houver endpoints não analisáveis sem execução real]

- COMANDO DE VALIDAÇÃO:
  - test -f docs/reverse_proxy_timeouts.md
  - git diff --name-only | grep -E '\.(go|conf|yml)$'

SESSION_LOG_END
```

#### REGRA DE CONTENÇÃO DE ESCOPO
Se houver qualquer dúvida entre:
- "criar configuração real otimizada"
- "apenas documentar valores mínimos seguros"

A resposta correta é: **APENAS DOCUMENTAR VALORES MÍNIMOS SEGUROS**.

#### CONDIÇÃO DE ENCERRAMENTO
Após esta tarefa:
- A **FASE 12.2** estará **ENCERRADA**
- O projeto poderá avançar para a **FASE 12.3** — Estratégia de Backup de Banco de Dados
- Nenhuma ação adicional é permitida após a entrega

---

**DECLARAÇÃO FINAL DE ESCOPO**:  
Esta fase é **exclusivamente documental**.  
Nenhum arquivo de configuração real será criado.  
Nenhum teste de carga será executado.  
Nenhuma otimização será implementada.