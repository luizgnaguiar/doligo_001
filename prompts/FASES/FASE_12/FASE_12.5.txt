 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────

## TAREFA ATIVA — FASE 12.5
### LOG ROTATION NO HOST (DOCUMENTAÇÃO TÉCNICA)

#### CONTEXTO DE EXECUÇÃO
Esta tarefa ocorre após o encerramento formal da FASE 12.4.1 (Correção de Crash em Inicialização Linux).

O sistema já possui:
- Documentação completa de variáveis de ambiente
- Documentação de timeouts de proxy
- Estratégia de backup documentada
- Binário executável validado em Linux
- Logs estruturados via `log/slog` (JSON)
- Logs enviados para `stdout`/`stderr`

O objetivo não é implementar rotação automática de logs, mas **documentar a política mínima** de rotação e fornecer orientações técnicas para operadores configurarem o sistema operacional.

#### OBJETIVO ÚNICO DA TAREFA
Criar documentação técnica clara sobre **política mínima de rotação de logs** e fornecer exemplos de configuração para ferramentas comuns de gerenciamento de logs no host.

Nada além disso.

#### PROBLEMA A SER RESOLVIDO
Atualmente:
- Aplicação loga para `stdout` (correto para containers)
- Não há política definida de tamanho máximo de logs
- Não há política de retenção temporal
- Operadores não sabem como configurar rotação no host
- Risco de disco cheio por acúmulo de logs

Esta fase corrige **exclusivamente** isso.

#### ESCOPO AUTORIZADO
Você pode somente:
1. **Definir** política mínima de rotação:
   - Tamanho máximo por arquivo
   - Quantidade de arquivos mantidos
   - Período de retenção
   - Compressão (sim/não)
2. **Documentar** configuração para ferramentas comuns:
   - `logrotate` (padrão Linux tradicional)
   - `journald` (systemd)
   - Docker logging drivers (se aplicável)
3. **Fornecer** exemplos reproduzíveis de configuração
4. **Esclarecer** que a aplicação **não gerencia** rotação internamente

#### RESTRIÇÕES ABSOLUTAS
Nesta fase, **NÃO** é permitido:
- Implementar rotação de logs na aplicação Go
- Criar sistema de logging para arquivo
- Modificar o sistema de logs existente (`slog`)
- Criar scripts de rotação customizados
- Implementar agregação de logs (ELK, Loki, etc.)
- Configurar exportação para serviços externos
- Criar dashboards ou alertas
- Antecipar fases futuras

Se algo parecer necessário mas fugir do escopo:  
→ **registrar como DÍVIDA TÉCNICA**  
→ **não implementar**

#### FORMATO OBRIGATÓRIO DO DOCUMENTO
O arquivo `docs/log_rotation.md` **DEVE** seguir este template:

```markdown
# Política de Rotação de Logs

**Versão**: 1.0.0  
**Data**: YYYY-MM-DD  
**Escopo**: Ambientes de produção sem agregação centralizada

---

## 1. Contexto Técnico

### Comportamento da Aplicação
A aplicação:
- Loga para `stdout` e `stderr` (padrão POSIX)
- Usa logs estruturados em JSON via `log/slog`
- **NÃO** gerencia rotação internamente
- **NÃO** escreve em arquivos diretamente

### Responsabilidade do Host
Toda rotação de logs é **responsabilidade do sistema operacional** ou do runtime de containers (Docker, systemd, etc.).

---

## 2. Política Mínima Recomendada

### Parâmetros de Rotação

| Parâmetro | Valor Recomendado | Justificativa |
|-----------|-------------------|---------------|
| Tamanho máximo por arquivo | 100 MB | Facilita análise manual, evita arquivos gigantes |
| Número de arquivos mantidos | 7 | Uma semana de histórico para troubleshooting |
| Período de retenção | 7 dias | Balanceamento entre espaço e rastreabilidade |
| Compressão | Sim (gzip) | Reduz uso de disco em ~70% |
| Rotação por tempo | Diária (meia-noite) | Alinhamento com ciclos de backup |

### Espaço em Disco Estimado
- **Sem compressão**: 7 × 100 MB = 700 MB
- **Com compressão**: ~210 MB
- **Margem de segurança**: 1 GB total

---

## 3. Configuração via logrotate

### Para Deployment Tradicional (Systemd)

Se a aplicação roda via `systemd` e loga para arquivo via redirecionamento:

```bash
# Serviço systemd (/etc/systemd/system/doligo.service)
[Service]
ExecStart=/usr/local/bin/doligo
StandardOutput=append:/var/log/doligo/app.log
StandardError=append:/var/log/doligo/error.log
```

Criar arquivo de configuração do `logrotate`:

```bash
# /etc/logrotate.d/doligo
/var/log/doligo/*.log {
    daily
    rotate 7
    size 100M
    compress
    delaycompress
    missingok
    notifempty
    create 0640 doligo doligo
    sharedscripts
    postrotate
        systemctl reload doligo.service > /dev/null 2>&1 || true
    endscript
}
```

**Validar configuração**:
```bash
# Testar sintaxe
sudo logrotate -d /etc/logrotate.d/doligo

# Forçar rotação manual (debug)
sudo logrotate -f /etc/logrotate.d/doligo
```

### Para Deployment sem Systemd

Se a aplicação roda diretamente e loga para arquivo:

```bash
# Iniciar aplicação com redirecionamento
nohup /usr/local/bin/doligo >> /var/log/doligo.log 2>&1 &
```

Configuração `logrotate`:

```bash
# /etc/logrotate.d/doligo
/var/log/doligo.log {
    daily
    rotate 7
    size 100M
    compress
    delaycompress
    missingok
    notifempty
    create 0640 root root
    copytruncate
}
```

**Nota**: `copytruncate` é necessário pois a aplicação não reabre o arquivo após rotação.

---

## 4. Configuração via journald (Systemd)

### Para Deployment via Systemd (Recomendado)

Se a aplicação roda via `systemd`, os logs vão automaticamente para `journald`:

```bash
# Serviço systemd (/etc/systemd/system/doligo.service)
[Service]
ExecStart=/usr/local/bin/doligo
# Logs vão para journald automaticamente
```

Configurar limites do `journald`:

```bash
# /etc/systemd/journald.conf
[Journal]
SystemMaxUse=1G
SystemKeepFree=2G
SystemMaxFileSize=100M
MaxRetentionSec=7day
Compress=yes
```

**Aplicar configuração**:
```bash
sudo systemctl restart systemd-journald
```

**Visualizar logs**:
```bash
# Logs da aplicação
journalctl -u doligo.service -f

# Logs com filtro JSON
journalctl -u doligo.service -o json-pretty

# Logs das últimas 24h
journalctl -u doligo.service --since "24 hours ago"
```

---

## 5. Configuração via Docker

### Docker Logging Driver (json-file)

Se a aplicação roda em container Docker:

```yaml
# docker-compose.yml
services:
  doligo:
    image: doligo:latest
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "7"
        compress: "true"
```

Ou via `docker run`:

```bash
docker run -d \
  --name doligo \
  --log-driver json-file \
  --log-opt max-size=100m \
  --log-opt max-file=7 \
  --log-opt compress=true \
  doligo:latest
```

**Visualizar logs**:
```bash
# Logs do container
docker logs -f doligo

# Logs com timestamps
docker logs -f --timestamps doligo
```

### Docker Logging Driver (journald)

Se o host usa `systemd`:

```yaml
# docker-compose.yml
services:
  doligo:
    image: doligo:latest
    logging:
      driver: "journald"
      options:
        tag: "doligo"
```

**Visualizar logs**:
```bash
# Logs via journalctl
journalctl CONTAINER_NAME=doligo -f
```

---

## 6. Validação da Configuração

### Checklist de Validação

- [ ] Política de rotação está configurada (logrotate, journald ou Docker)
- [ ] Tamanho máximo por arquivo definido
- [ ] Número de arquivos de retenção configurado
- [ ] Compressão está habilitada
- [ ] Espaço em disco disponível (mínimo 1GB)
- [ ] Rotação foi testada manualmente

### Comandos de Teste

#### logrotate
```bash
# Simular rotação (dry-run)
sudo logrotate -d /etc/logrotate.d/doligo

# Forçar rotação
sudo logrotate -f /etc/logrotate.d/doligo

# Verificar arquivos rotacionados
ls -lh /var/log/doligo/
```

#### journald
```bash
# Verificar uso de disco
journalctl --disk-usage

# Limpar logs antigos manualmente
sudo journalctl --vacuum-time=7d
sudo journalctl --vacuum-size=500M
```

#### Docker
```bash
# Verificar configuração de logging
docker inspect doligo | grep -A 10 LogConfig

# Verificar tamanho dos logs
du -sh /var/lib/docker/containers/$(docker ps -qf name=doligo)/*-json.log*
```

---

## 7. Monitoramento e Alertas (Básico)

### Indicadores de Saúde

Monitorar manualmente:
- Uso de disco em `/var/log` ou `/var/lib/docker`
- Quantidade de arquivos `.log` ou `.log.gz`
- Idade do arquivo mais antigo

### Exemplo de Script de Monitoramento

```bash
#!/bin/bash
# /usr/local/bin/check-log-disk.sh

LOG_DIR="/var/log/doligo"
MAX_USAGE_PERCENT=80

USAGE=$(df -h "$LOG_DIR" | awk 'NR==2 {print $5}' | sed 's/%//')

if [ "$USAGE" -gt "$MAX_USAGE_PERCENT" ]; then
    echo "ALERTA: Uso de disco em $LOG_DIR está em ${USAGE}%"
    exit 1
else
    echo "OK: Uso de disco em ${USAGE}%"
    exit 0
fi
```

**Nota**: Este script é apenas exemplo. Automação de alertas está fora do escopo.

---

## 8. Limitações e Riscos Conhecidos

### Limitações da Estratégia
- Rotação depende de configuração correta do host
- Sem validação automática de configuração
- Sem agregação centralizada de logs
- Sem alertas automáticos de falha de rotação

### Riscos Aceitos
- Logs podem ser perdidos se rotação falhar silenciosamente
- Disco pode encher se política não for aplicada
- Troubleshooting limitado a 7 dias de histórico

### Quando Revisar Esta Estratégia
- Volume de logs ultrapassar 1GB/dia
- Necessidade de retenção > 7 dias
- Necessidade de busca full-text em logs
- Múltiplas instâncias da aplicação (agregação necessária)

---

## 9. Próximos Passos (Fora de Escopo)

Melhorias futuras não implementadas nesta fase:
- Agregação centralizada (ELK, Loki, CloudWatch)
- Alertas automáticos de falha de rotação
- Exportação de logs para storage externo
- Análise de logs com ferramentas de BI
- Correlação de logs entre múltiplos serviços

---

**Documento produzido em conformidade com FASE 12.5**  
**Nenhuma implementação de rotação interna foi criada**  
**Configuração é responsabilidade do host/runtime**
```

#### REGRAS DE DOCUMENTAÇÃO
Cada configuração **DEVE**:
1. Ser reproduzível pelo operador
2. Usar ferramentas padrão do sistema operacional
3. Ter comandos de validação fornecidos
4. Incluir valores conservadores (não otimizados)

É **PROIBIDO**:
- Criar biblioteca de logging interna
- Implementar rotação na aplicação
- Criar scripts automáticos de rotação
- Assumir ferramentas não-padrão instaladas
- Integrar com serviços cloud

#### CRITÉRIO DE VALIDAÇÃO
A fase só é considerada concluída se:

1. O arquivo `docs/log_rotation.md` existe
2. Contém exemplos para `logrotate`, `journald` E Docker
3. Valores de política estão justificados
4. Nenhum arquivo `.go` foi modificado
5. Nenhum script real foi criado

**Comando de validação**:
```bash
# Verificar que nenhum arquivo Go foi modificado
git diff --name-only | grep -E '\.go$' && echo "FALHA: Arquivo Go modificado" || echo "OK"

# Verificar que nenhum script foi criado
test -f scripts/logrotate.sh && echo "FALHA: Script criado" || echo "OK"

# Verificar existência do documento
test -f docs/log_rotation.md && echo "OK: Documento existe" || echo "FALHA: Documento ausente"
```

#### SAÍDA OBRIGATÓRIA
Ao final, gerar um **SESSION_LOG** contendo:

```
SESSION_LOG_START | Versão: v1.0.0 | Data: DD/MM/YYYY
- ARQUIVOS CRIADOS/MODIFICADOS:
  - docs/log_rotation.md

- RESUMO TÉCNICO:
  - Política mínima de rotação definida (tamanho, retenção, compressão)
  - Exemplos de configuração fornecidos para logrotate, journald e Docker
  - Comandos de validação incluídos
  - Checklist de implementação criado
  - Nenhuma modificação de código foi realizada

- DÍVIDA TÉCNICA / PENDÊNCIAS:
  - Automação de rotação via scripts não implementada
  - Monitoramento de falha de rotação não implementado
  - Agregação centralizada de logs não implementada

- COMANDO DE VALIDAÇÃO:
  - test -f docs/log_rotation.md
  - git diff --name-only | grep -E '\.(go|sh)$'

SESSION_LOG_END
```

#### REGRA DE CONTENÇÃO DE ESCOPO
Se houver qualquer dúvida entre:
- "implementar rotação automática na aplicação"
- "apenas documentar configuração do host"

A resposta correta é: **APENAS DOCUMENTAR CONFIGURAÇÃO DO HOST**.

#### CONDIÇÃO DE ENCERRAMENTO
Após esta tarefa:
- A **FASE 12.5** estará **CONCLUÍDA**
- O **GRUPO 12** (Prontidão Operacional) estará **ENCERRADO**
- O projeto terá documentação completa de operações básicas
- Todas as tarefas de pré-produção estarão documentadas

---

**DECLARAÇÃO FINAL DE ESCOPO**:  
Esta fase é **exclusivamente documental**.  
A aplicação **não gerencia rotação internamente**.  
Rotação é **responsabilidade do host/runtime**.  
Documentação fornece **orientação técnica reproduzível**.

