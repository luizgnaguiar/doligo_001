 MODO DE EXECUÇÃO OBRIGATÓRIO

ANTES DE QUALQUER ANÁLISE OU GERAÇÃO DE SAÍDA:

Você DEVE:
1. Ler integralmente o arquivo AGENT_CONTRACT.txt
2. Operar estritamente sob as regras definidas nele
3. Recusar qualquer ação que viole o contrato

HIERARQUIA DE PRECEDÊNCIA (OBRIGATÓRIA):
1. AGENT_CONTRACT.txt (autoridade máxima)
2. Especificação abaixo (tarefa)

Se houver qualquer conflito, ambiguidade ou lacuna,
o AGENT_CONTRACT.txt prevalece sem exceções.

────────────────────────────────────────────────────────────
ESPECIFICAÇÃO DA TAREFA
────────────────────────────────────────────────────────────
 
 Título: Especificação de Engenharia: Sistema de ERP/CRM (Dolibarr-Go) - Arquitetura de Produção
  Papel: Atue como Arquiteto de Software Sênior e Especialista em Go (Golang).
  Objetivo: Projetar a estrutura técnica e os contratos de interface de um ERP/CRM robusto, seguindo
  rigorosamente os padrões de Clean Architecture e as restrições de infraestrutura moderna.
  1. Restrições de Compilação e Ambiente
  • Binário Estático: Proibido o uso de CGO. Toda a solução deve compilar com CGO_ENABLED=0.
  • Drivers Pure Go: Utilize pgx (PostgreSQL) e go-sql-driver/mysql (MySQL).
  • Encapsulamento de Assets: Todos os arquivos externos (SQL Migrations, templates de E-mail/PDF e arquivos
  i18n JSON) devem ser lidos via go:embed.
  • Versão do Go: 1.22 ou superior (utilizando melhorias de iteradores e performance de loops).
  2. Arquitetura e Fluxo de Dados
  • Estrutura de Pastas: * /cmd: Entrypoints da aplicação.
  • /internal/domain: Entidades puras e interfaces de repositórios/serviços.
  • /internal/usecase: Orquestração da lógica de negócio.
  • /internal/infrastructure: Implementações de banco, drivers e serviços externos.
  • /internal/api: Handlers, Middlewares e DTOs (Echo v4).
  • Mapeamento Rigoroso:
  1. API -> Usecase: O Handler recebe um RequestDTO, valida-o e converte-o em uma Entity de Domínio.
  2. Usecase -> Repository: O Usecase opera apenas com Entities.
  3. Repository -> DB: O Repository converte a Entity em um Model GORM para persistência.
  • Injeção de Dependência: Implementação via construtores manuais no main.go ou wire, priorizando a
  testabilidade por interfaces.
  3. Concorrência e Resiliência
  • Gestão de Contexto: Todo método de Usecase e Repository deve aceitar context.Context.
  • Pessimistic Locking: Operações críticas de estoque (Stock/Product) devem utilizar
  db.Clauses(clause.Locking{Strength: "UPDATE"}) para evitar condições de corrida em ambiente distribuído.
  • Internal Task Runner: Implementar um Worker Pool baseado em channels.
  • Deve suportar Graceful Shutdown: ao receber SIGTERM, o sistema deve parar de aceitar novas tarefas e
  processar o buffer existente até um limite de 15 segundos.
  • Tarefas de IO (PDF/Email) devem ter timeout de 30s via context.
  • Circuit Breaker: Implementar política de retries simples para envio de e-mails falhos.
  4. Persistência e Integrações
  • ORM: GORM v2 para CRUDs, mas com suporte a SQL puro para relatórios complexos.
  • Pool de Conexões: Parametrizar MaxOpenConns, MaxIdleConns e ConnMaxLifetime via variáveis de ambiente.
  • Migrações: Utilizar golang-migrate/migrate embutido no binário.
  • Documentos: Geração de PDF utilizando a biblioteca maroto (pure Go).
  5. Segurança e Observabilidade
  • Auth: JWT Stateless. Middleware de RBAC validando permissões por Claims.
  • Logs: Implementar estruturação de logs via ZeroLog ou Zap com injeção de request_id no contexto.
  • Health Checks: Endpoints /health (liveness) e /ready (readiness - checando DB).
  6. Casos de Teste Obrigatórios (Critérios de Aceite)
  1. CT-01 (Portabilidade): O binário compilado deve rodar em uma imagem Docker scratch sem dependências de
  SO.
  2. CT-02 (Concorrência): Validar que duas transações simultâneas de débito de estoque resultam em bloqueio
  sequencial (Pessimistic Lock).
  3. CT-03 (Cancelamento): Validar que o fechamento da conexão pelo cliente interrompe a goroutine de
  geração de PDF.
  4. CT-04 (Shutdown): Validar que tarefas no Internal Task Runner terminam de processar após um sinal de
  interrupção, sem perda de dados imediata.

────────────────────────────────────────────────────────────
INÍCIO DA EXECUÇÃO
────────────────────────────────────────────────────────────

Perfeito! A FASE 12.3 foi concluída com sucesso. Vou agora construir a especificação da **FASE 12.4** seguindo o mesmo rigor arquitetural.

---

## TAREFA ATIVA — FASE 12.4
### EXECUÇÃO EM AMBIENTE LINUX REAL (VALIDAÇÃO OPERACIONAL)

#### CONTEXTO DE EXECUÇÃO
Esta tarefa ocorre após o encerramento formal da FASE 12.3 (Estratégia de Backup de Banco de Dados).

O sistema já possui:
- Documentação completa de variáveis de ambiente
- Documentação de timeouts de proxy
- Estratégia de backup documentada
- Binário estático compilável com `CGO_ENABLED=0`
- Dockerfile `FROM scratch` validado

O objetivo não é corrigir bugs ou otimizar código, mas **validar explicitamente** que o binário Linux pode ser executado em um ambiente real e que a aplicação inicializa corretamente.

#### OBJETIVO ÚNICO DA TAREFA
Executar o binário compilado para Linux em um ambiente Linux real (VM, container Docker, ou CI Linux) e **registrar evidência explícita** de que:
1. O binário é executável
2. A aplicação inicia corretamente
3. O endpoint `/health` responde

Nada além disso.

#### PROBLEMA A SER RESOLVIDO
Atualmente:
- A compilação foi validada em FASE 8.1
- Execução em container `scratch` foi validada em FASE 8.1-R
- **Falta evidência explícita** de execução direta do binário em Linux

Esta fase corrige **exclusivamente** isso.

#### ESCOPO AUTORIZADO
Você pode somente:
1. **Compilar** o binário para Linux:
   ```bash
   CGO_ENABLED=0 GOOS=linux go build -o doligo ./cmd/main.go
   ```
2. **Executar** o binário em um dos ambientes válidos:
   - VM Linux (Ubuntu, Debian, RHEL, etc.)
   - Container Docker Linux
   - Pipeline de CI/CD Linux (GitHub Actions, GitLab CI, etc.)
3. **Verificar**:
   - O binário tem permissão de execução
   - A aplicação inicia sem crash imediato
   - Logs de inicialização aparecem
   - Endpoint `/health` responde (mesmo com falha de DB)
4. **Registrar** a evidência no `SESSION_LOG`

#### RESTRIÇÕES ABSOLUTAS
Nesta fase, **NÃO** é permitido:
- Modificar código Go
- Corrigir bugs encontrados durante execução
- Alterar variáveis de ambiente obrigatórias
- Implementar workarounds para falhas de inicialização
- Criar scripts de deployment
- Configurar serviços systemd
- Otimizar performance
- Executar testes automatizados
- Antecipar FASE 12.5 ou posteriores

Se algo parecer necessário mas fugir do escopo:  
→ **registrar como DÍVIDA TÉCNICA**  
→ **não implementar**

#### AMBIENTES VÁLIDOS PARA VALIDAÇÃO
Escolha **UM** dos seguintes:

##### Opção 1: Container Docker Linux
```bash
# Build
CGO_ENABLED=0 GOOS=linux go build -o doligo ./cmd/main.go

# Executar em container Linux
docker run --rm -v $(pwd)/doligo:/app/doligo -p 8080:8080 \
  ubuntu:22.04 /app/doligo

# Verificar (em outro terminal)
curl http://localhost:8080/health
```

##### Opção 2: VM Linux (se disponível)
```bash
# Build local
CGO_ENABLED=0 GOOS=linux go build -o doligo ./cmd/main.go

# Transferir para VM
scp doligo user@vm-linux:/tmp/doligo

# Executar na VM
ssh user@vm-linux
chmod +x /tmp/doligo
/tmp/doligo

# Verificar
curl http://localhost:8080/health
```

##### Opção 3: GitHub Actions / GitLab CI
```yaml
# .github/workflows/validate-linux.yml
name: Validate Linux Binary
on: [workflow_dispatch]
jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v4
        with:
          go-version: '1.22'
      - name: Build
        run: CGO_ENABLED=0 GOOS=linux go build -o doligo ./cmd/main.go
      - name: Execute
        run: |
          chmod +x doligo
          ./doligo &
          sleep 5
          curl http://localhost:8080/health
```

#### COMPORTAMENTO ESPERADO
A aplicação **DEVE**:
1. ✅ Iniciar sem crash de "exec format error"
2. ✅ Logar tentativa de conexão com DB (pode falhar, é esperado)
3. ✅ Iniciar servidor HTTP na porta configurada
4. ✅ Responder `/health` com HTTP 200

A aplicação **PODE**:
- ❌ Falhar ao conectar com banco de dados (esperado se não configurado)
- ⚠️ Logar erros de inicialização de serviços (esperado)
- ⚠️ Rotas protegidas retornarem 503 (esperado sem DB)

#### CRITÉRIO DE VALIDAÇÃO
A fase só é considerada concluída se:

1. **Evidência de execução** foi registrada no `SESSION_LOG`:
   - Ambiente utilizado (Docker/VM/CI)
   - Comando de build executado
   - Comando de execução executado
   - Resposta do `/health` (status code e body)
2. Nenhum arquivo `.go` foi modificado
3. Nenhum workaround foi implementado

**Comando de validação**:
```bash
# Verificar que nenhum arquivo Go foi modificado
git diff --name-only | grep -E '\.go$' && echo "FALHA: Arquivo Go modificado" || echo "OK"

# Evidência deve estar no SESSION_LOG
grep "EVIDÊNCIA DE EXECUÇÃO" SESSION_LOG.txt || echo "AVISO: Evidência não registrada"
```

#### TRATAMENTO DE FALHAS
Se o binário **NÃO executar** corretamente:

1. **Registrar a falha** no `SESSION_LOG`
2. **Classificar o erro**:
   - ❌ Exec format error → BLOQUEADOR (arquitetura incompatível)
   - ❌ Permission denied → OPERACIONAL (chmod necessário)
   - ⚠️ DB connection failed → ESPERADO (não é falha)
   - ⚠️ Crash em 5s → DÍVIDA TÉCNICA (investigar em fase futura)
3. **NÃO corrigir nesta fase**

Se a falha for **BLOQUEADORA**:
→ A FASE 12.4 é declarada **FALHA**  
→ Investigação e correção devem ocorrer em fase dedicada

#### SAÍDA OBRIGATÓRIA
Ao final, gerar um **SESSION_LOG** contendo:

##### Caso de Sucesso:
```
SESSION_LOG_START | Versão: v1.0.0 | Data: DD/MM/YYYY
- ARQUIVOS CRIADOS/MODIFICADOS:
  - Nenhum

- RESUMO TÉCNICO:
  - Binário compilado com CGO_ENABLED=0 GOOS=linux
  - Executado em [AMBIENTE: Docker/VM/CI]
  - Aplicação iniciou corretamente
  - Endpoint /health respondeu com HTTP 200

- EVIDÊNCIA DE EXECUÇÃO:
  Ambiente: [Docker ubuntu:22.04 / VM Ubuntu 22.04 / GitHub Actions]
  
  Comando de build:
  $ CGO_ENABLED=0 GOOS=linux go build -o doligo ./cmd/main.go
  
  Comando de execução:
  $ [comando usado]
  
  Logs de inicialização (primeiras 10 linhas):
  [colar logs]
  
  Resposta do /health:
  $ curl http://localhost:8080/health
  HTTP/1.1 200 OK
  {"status":"ok"}

- DÍVIDA TÉCNICA / PENDÊNCIAS:
  - Nenhuma (ou listar se aplicável)

- COMANDO DE VALIDAÇÃO:
  - Executado manualmente conforme evidência acima

SESSION_LOG_END
```

##### Caso de Falha:
```
SESSION_LOG_START | Versão: v1.0.0 | Data: DD/MM/YYYY
- ARQUIVOS CRIADOS/MODIFICADOS:
  - Nenhum

- RESUMO TÉCNICO:
  - Binário compilado com CGO_ENABLED=0 GOOS=linux
  - Tentativa de execução em [AMBIENTE]
  - FALHA DETECTADA: [classificação da falha]

- EVIDÊNCIA DE FALHA:
  Ambiente: [Docker/VM/CI]
  
  Comando de build:
  $ CGO_ENABLED=0 GOOS=linux go build -o doligo ./cmd/main.go
  
  Comando de execução:
  $ [comando usado]
  
  Erro obtido:
  [colar erro completo]
  
  Classificação: [BLOQUEADOR / OPERACIONAL / ESPERADO]

- DÍVIDA TÉCNICA / PENDÊNCIAS:
  - Investigação de causa raiz da falha [BLOQUEADOR/OPERACIONAL]
  - Correção deve ocorrer em fase dedicada

- COMANDO DE VALIDAÇÃO:
  - N/A (execução falhou)

- DECLARAÇÃO DE FALHA:
  FASE 12.4 NÃO ATENDIDA

SESSION_LOG_END
```

#### REGRA DE CONTENÇÃO DE ESCOPO
Se houver qualquer dúvida entre:
- "corrigir o erro encontrado"
- "apenas registrar a evidência"

A resposta correta é: **APENAS REGISTRAR A EVIDÊNCIA**.

#### CONDIÇÃO DE ENCERRAMENTO

##### Se SUCESSO:
- A **FASE 12.4** estará **CONCLUÍDA**
- O projeto poderá avançar para a **FASE 12.5** — Log Rotation no Host
- A validação operacional está formalmente registrada

##### Se FALHA:
- A **FASE 12.4** estará **BLOQUEADA**
- Correção deve ser priorizada antes de FASE 12.5
- Investigação técnica deve ocorrer em fase dedicada

---

**DECLARAÇÃO FINAL DE ESCOPO**:  
Esta fase é **exclusivamente validação operacional**.  
Nenhum código será corrigido.  
Nenhum workaround será implementado.  
Apenas evidência de execução será registrada.